# 运行时时空管理
## 运行时内存划分
### 库代码区（libaray space）
用于存放标准库函数的目标代码，例如pascal语言中用到的sin、cos等等。高级函数，如C语言中通过#include包含进来的库代码；
### 目标代码区(code space)
用以存放编译生成的目标程序。实际上一个目标程序变成可执行文件需要连接-装配的过程，连接装配之后存放在目标代码区。
### 静态区(static space) 
有些数据对象所占用的空间也能在编译时确定，其地址可以编译进目标代码中，这些数据对象通常存放在静态区中，如静态变量和全局变量
### 栈区（stack space）
存放过程活动记录，该存储区被称作一个栈，一个元素是一个过程活动记录，调用函数时压栈，函数结束时退栈
### 堆区（heap space）
堆不是一个连续分配的模式，可以进行动态分配的空间管理，主要用于存放动态申请的数据对象 （如C，pascal ，Lisp等语言的malloc,calloc,free,new,delete）

栈区和堆区之间没有事先划好的界线，当目标代码运行时，栈区指针和堆区指针不断地变化，并朝着对方方向不断增长。如果这两个区相交，则表示出现了内存溢出。

## 语言影响空间分配策略
### 语言中是否允许函数、过程的递归调用
语言如果允许递归调用，则函数的形参、局部量可能对应是一串存储单元，不能采用静态的存储分配方式；如语言不允许有递归出现，则一个函数最多只能分配一个活动记录大小的空间。
### 当一个函数结束的时局部变量是否需要保存
一般来说，一个函数的局部变量在函数调用结束的时候所占用的存储空间都要被释放掉，但是有一类语言的特殊语句，允许函数中的某个局部变量保存着，下一次再调用这个函数的时候，这个局部变量是已经具有上一次语言的值
### 是否可以访问非局部的变量
比方说外层的变量，还有其他的变量是否可以访问，不同的语言也有不同的约定
### 函数参数的传递方式
常用的参数传递方式是值引用和地址引用，这就决定了地址引用型的实参只能是一个变量而不能是一个常数，形参的值引用和地址引用的空间分配的方式是不一样的。
### 其他
- 函数是否可以作为参数进行传递
- 函数的结果是否可以为函数
- 动态的申请存储块
- 是否显示的释放存储空间

## 存储管理模式分类
- 静态存储分配策略
静态分配策略在编译时为数据对象分配固定的存储空间，且存储对象的存储位置在程序的整个生命周期是固定的。
完全采用静态分配策略的语言必须满足以下约束条件：
    1. 不允许递归过程。
    1. 不允许可变体积的数据，即数据对象的长度和它在内存中位置的限制，必须是在编译时可知。
    1. 不允许动态建立的数据结构（如动态数组、指针等），因为没有运行时的存储分配机制。

- 动态存储分配策略
    - 栈式动态存储分配策略
    - 堆式动态存储分配策略
    可以分为：
        1. 栈式。是一种最常见的模式，在有函数调用的时候动态的分配存储空间；若程序运行过程中有动态进行申请和释放程序空间，用栈式的就不行了,没有办法静态的在活动记录里给分配空间
        1. 栈堆混合式，活动记录的大小确定的存在栈区中，动态申请的空间在堆区中申请然后释放，同时增加一部分对堆区的管理程序
    
## 栈式管理中的过程活动记录
### 过程的活动记录
为管理过程、函数的一次活动所需要的信息，目标程序要在栈区中给被调过程分配一段连续的存储空间，以便存放该过程的局部变量值、控制信息和寄存器内容等，称这段连续的存储空间为过程的活动记录，简称活动记录（Activation Record），并记为AR。

过程活动记录的是栈式管理中最重要的内容
栈区中通常需要设立两个指针：
- sp 指向当前活动记录的起始位置
- top指向第一个可用的存储单元

通常存在寄存器中
| 临时变量区 |
| --- |
| 局部变量区 |
| 形参区 |
| 变量访问环境 |
| 活动记录大小 |
| 寄存器状态 |
| 过程层数 |
| 返回值 |
| 返回地址 |
| 动态链指针 |
### 地址分配原则
- 值引用的形参按照类型大小分
- 地址引用的形参分配1
- 局部变量按照类型长度分
- 临时变量分1
- 函数和过程作为形参分2，其中1个是实参的入口地址，另一个是先行的display表地址

### 过程活动记录的申请和释放
1. 遇到函数过程调用时申请地址，具体来看在遇到call四元式中间代码时，要生成相应的目标代码。要做的工作有两个：
    - 产生一个新的活动记录，即sp=top，top=top+size
    - 填写过程活动记录的管理信息，返回地址、寄存器内容、动态链指针等等
1. 释放一个是遇到了return，一个是遇到了函数的结束要做的主要工作有：
    - 恢复现场，将寄存器里的值恢复
    - 释放当前活动记录即top=sp; sp=动态链指针
    - 根据返回地址创建跳转指令

#### 调用链
- 对于任一过程（函数）S，其调用链不是唯一的，每个调用链对应于一个动态的过程调用序列。
- 用CallChain(S)=(M，…，R，S)表示S的调用链，表示当前正在执行的是S的过程体，而M，…，R则是已经开始执行但被中断了的过程。

#### 动态链
动态链：如果当前正在执行的是S，并且
CallChain(S)= (M，N,…，R，S)，则栈的当前内容可表示为：
\[AR(M),AR(N),…，AR(R),AR(S)]，称它为对应调用链（M，N ， …，R，S）的动态链。
表示为：
DynamicChains（S）= [AR（M),AR（N),…,AR（R),AR（S）] 

#### 活跃活动记录
LiveAR（LAR）:
一个过程S在动态链中可有多个AR，但其中只有最新AR(S )是可访问的，称此AR(S)为S的活跃活动记录，并记为LiveAR(S)，简写为LAR（S）。


## 变量的地址映射
### 并列式语言
相对简单只有0层和1层，可以用两个指针来解决，sp0指向全局量的首地址，sp指向当前活动记录的首地址，根据变量的层数来确定是sp0+off还是sp+off。
`int x,y; int f(){int i; y=x*i; return y;}`
值得注意的是const变量也在静态区中

### 嵌套式语言
相比之下复杂一些
若抽象地址是L,off,如果L等于当前层，则说明他所对应的变量处于当前的活动记录中，如果L不等于当前层，就要找到他所对应的活动记录的首地址，为此要构造一个display表，把每一个活动记录活跃的静态外层的首地址都存起来，然后找到L所对应的那一层的首地址加上off就可以了

## 变量访问环境
### 声明链
过程声明链(DeclaChain):过程名序列（M）是过程声明链，M是主程序名；若(M,…,P)是过程声明链，且P中有过程Q的声明，则(M,…,P,Q)也是过程声明链；
记为：DeclaChain(Q)=( M,…,P,Q )
### 变量访问环境
当前变量访问环境VarVisitEnv:
  若DeclaChain(Q)= [M,…,P,Q]则
VarVisitEnv(LAR(Q))=[LAR(M),…,LAR(P),LAR(Q)]
```
(M,P,Q,R)为R的声明链，假设有当前调用链是(M,P1,P2,Q1,R1,R2,R3 )
则当前动态链为：   
[AR(M),AR(P1),AR(P2),AR(Q1),AR(R1),AR(R2),AR(R3)]
R的当前变量访问环境:
VarVisitEnv(LAR(R)) =[AR(M), AR(P2),AR(Q1),AR(R3)]
```
#### 非局部变量访问
假设Q的变量访问环境:
VarVisitEnv（LAR（Q）） 
= \[LAR（M）,…，LAR（P），LAR（Q）] ，在Q中有变量XQ，YM，ZP，它们分别定义在过程Q、M和P中，则它们的存储单元地址可表示如下（其中<LAR（Q）>表示LAR（Q）的始地址，其它类似）：
addr( XQ )= <LAR（Q）> + OffsetX
addr( YM )= <LAR（M）> + OffsetY
addr( ZP )= <LAR（P）> + Offsez

结论: 对于每个AR，只要知道了它的变量访问环境VarVisitEnv（AR），即可实现包括非局部变量在内的所有变量的访问。

#### 计算当前过程的变量访问环境
1. 情况1：P调用P ： P层数等于P层数N
1. 情况2： P调用Q,P层数等于Q层数N.
DeclaChain(P)= (M，P1, P2,…,PN-1,P)
DeclaChain(Q)=( M，P1, P2,…,PN-1,Q)
1. 情况3： P调用Q ,P层数(N-1)小于Q层数(N).
DeclaChain(P)= (M，P1, P2,…,PN-2,P)
DeclaChain(Q)=(M，P1, P2,…,PN-2, P , Q)
1. 情况4：P调用Q,P层数大于Q层数(N)
DeclaChain(Q)=(M，P1, P2,…,PN-1, Q)
DeclaChain(P)= (M，P1, P2,…,PN-1,Q，…，P)

定理：设[AR(M),…,AR(P),AR(Q)]∈DynamicChain(Q),且Q 的层数为N，则有：
VarVisitEnv(AR(Q)) = VarVisitEnv(AR(P))_N + AR(Q)
结论：变量访问环境可由先行过程的变量访问环境求得.

#### 变量访问环境的实现方法
#### Display表方法
##### 全局表法
每个程序设置一个总的Display表，其长度为最大嵌套层数（最长声明链的长度），其中Display[i]存放第i层最新AR的指针,用D[i]表示。
该方法的理论依据：在程序的任何一点，相同层数的过程声明只能有一个有效。
在AR中设置一个Resume单元，用来临时保存某D[i]

- 当层数为j的过程Q被调用时：
    1. 将旧的D[j]的内容保存到NewAR(Q)中： NewAR(Q).ResumeAddr = D[j];
    1. 改写D[j]的内容：D[j]=NewAR(Q)的地址；
- 当退出Q时：恢复原来D[j]的内容：
D[j] = CurrentAR.ResumeAddr
- 局部变量X(L,off,indir/dir)的访问
X的地址： addr(X)= D[L]+off


##### 局部表法
对于每个AR求出其变量访问环境，并把它以地址表的形式(Display表)保存在AR中。因为每个AR都自带Display表，称这种方法为局部化Display表方法。
如果层数为N的过程P的变量访问环境为：
VarVisitEnv(AR(P))=[AR0,…,ARn],
ari表示ARi的始地址，则
[ar0,…,arn]是AR(P)的Display表.   

对一个变量X(L, off)，地址为：
当L= CurrentAR.level时：addr(X)=sp+off
否则:addr(X)=CurrentAR.Display[L]+ off
即[sp+D+L]+off



#### 静态链方法
原Display表部分变成一个单元，称为静态链单元，存放静态链指针。
静态链指针的确定：
若 k= CurrentAR.level+1-NewAR.level，则  NewAR.StaticChainPointer=Indir(sp,k)
其中Indir(sp,k)表示sp的k次间接内容。

#### 总结
Display表方法是用表结构表示变量访问环境。	
- 局部Display表的产生需要花时间，但返回时不需要为恢复变量访问环境做任何事情。
- 对于全局Display表方法而言，Display表的产生需要花时间，而且返回时也需要为恢复变量访问环境而花时间，其主要优点是能节省存储单元。

- 静态链方法是用链表表示变量访问环境
静态链方法实际上是一种共享化的局部Display表方法。其主要优点同全局Display表方法是能节省存储单元。产生需要花时间，但返回时不需要为恢复变量访问环境做任何事情。

- 具体采用哪种方法，取决于机器条件：如果寄存器较少，则使用Display表方法可能合适些；如果机器能提供较好的间接操作，则可选用静态链方法。

