# 目标代码生成
## 四元式转化为目标指令
四元式等价的转换成目标指令需要用到两个栈：
### 标号定位栈L1
定位性标号是为了某些转移提供地址的，需要把暂时没用到的标号存在栈中，例如while四元式可以对应一个嵌套的循环，在定位产生时还没产生跳转指令，它的地址还没用到，为了让后面能用到需要用栈把标号保存下来
### 目标指令地址栈L2
在有些产生跳转指令的时候，转移地址暂时无法确定，例如do四元式，不知道后面的转移地址，则把当前目标指令地址存到栈里，在知道转移地址以后，回填这个指令地址。回填地址是编译中的一项非常重要的技术

### 转化
**运算型**四元式（Op，X，Y，T）：对应生成3条指令   
LD R X； 把X取到R中
Op R Y； 根据运算符对应的运算生成指令，结果存入R
ST T R； 将R中的内容存入T中 
两点重要的解释：
1. 目标指令中X，Y，T对应的一个具体的地址，如sp+offX
1. 如果XY为间接变量，这里的寻址方式为间接，如X为间接变量，用*X表示他是一个间接寻址方式。

**赋值型**的四元式(=,x,-,y):生成的目标指令是两条
LD R X; 把x取到寄存器中
ST Y R; 把寄存器中的内容存到y中

输入语句四元式的一般形式为：
(READ，_ , _ , A )
表示将一个外部值读入到变量A中，则生成的代码下：
IN  R ;  ST A R
输出语句的四元式形式一般为：
(WRITE，A , _ , _ )
表示将变量A的值输出，它生成的目标代码为：
LD R A; OUT R 

#### if
(then, x,-,-) 实际产生一条半指令
\[n] LD R X；           一条
\[n+1]JMPF R *（地址）  半条
同时把转移指令地址n+1压入L2栈

(ELSE,-,-,-)，else在起到定位和转移的作用，因此要产生跳转指令和地址的回填。
[m-1]……
地址回填，从L2栈中取出指令，将m+1作为地址加入该指令:[n+1]JMPF R m+1   (跳到else)
[m] JMP  *
将m压入L2栈
[m+1]……
（ENDIF, __ , __ , __），定位作用，不产生目标指令，只回填地址

#### while
while循环语句的翻译：WHILE DO ENDWHILE
（WHILE，-，-，-）起到一个定位作用，不产生指令，
[n]… …
[n+1]记录当前目标指令地址n+1，压入L1栈

循环语句的翻译while：
(DO，X，-，-)生成两条指令
[m] LD X R； 
[m+1] JMPF R *
m+1压入L2栈，后面遇到再回填

循环语句的翻译while：
(endwhile，-，-，-)生成一条指令
[k]JMP L1(top)； L1栈顶出栈
将地址k+1回填给L2栈顶代码：JMPF R k+1
L2栈顶出栈
[k+1]……

#### label
分成内存保存标号和不保存标号两种，按不保存标号处理。

- 标号语句： (lable,-,- L) ，将当前目标代码地址存入L对应的标号表单元。
- goto语句： (goto,-,-,L) 产生一个无条件转移指令  JMP   *（L），对应的地址暂时为一个指向标号表L的指针。

目标代码全部生成以后，对所有由(goto,-,-,L)生成的目标指令，依据标号表中对应的目标代码地址信息，进行地址回填。 

#### 过程/函数声明
(ENTRY, Q,-,-)
入口四元式不产生任何指令，而是把当前指令地址填入函数信息表中。
(ENDFUNC, -,-,-)
1. 生成一组读取命令，即恢复寄存器的现场信息
1. 作废当前的活动记录，由两个指令完成，把当前的sp存给top，把动态链指针存给sp 
ST  top , sp ；LD  sp , *0(top) 
1. 产生一条返回指令，根据返回地址生成一个跳转指令。jmp *1（top）

*设过程活动记录首单元存动态链指针、第二个单元存返回地址

#### 过程/函数调用
值参四元式( ValACT , t , Offset , size )
1. 若t为间接变量，则生成的目标代码为：
LD  R , * t 
ST  Offset(top) , R
1. 若t 为直接变量，则生成的目标代码为：
LD R , t 
ST  Offset(top) , R  
1. 若t 为数组，则生成成组传送的目标代码：
MOVEB  t , Offset(top) , size 

变参四元式( VarACT , t , Offset , size )
1. 若t为直接变量，则生成的目标代码为：
LEA  R , t
ST  offset(top) , R
1. 若t为间接变量，则生成的目标代码为：
LD  R , t 
ST  offset(top) , R

函数调用四元式的处理:
( CALL , f,  true , [ Result ] )
1. 生成填写变量访问环境指令
1. 把机器状态(寄存器内容)保存到活动记录的机器状态区中,一般应生成一组存的指令
1. 要填写管理信息.首先填写过程层数.从过程f的语义信息中取其层数,填入到3（top）中,生成指令为
LD  R , sem[f].level
ST  3(top), R
1. 填写动态链指针
ST  0(top), sp
1. 填写返回地址
[A]   LD  R, A+5         
[A+1] ST  1(top), R 
1. 生成过程活动记录
[A+2] ST  sp, top 
[A+3] ST  top, top + sem[f].size
1. 生成转向过程f入口的指令
[A+4] JMP  sem[f].code 
1. 如果是函数调用，则把函数值读到寄存器中
[A+5] LD  R ， 2(top) 
[A+6] ST  t ,  R 
 
### 多寄存器的分配
为了产生更高效的目标代码，合理利用寄存器资源，需要构造一个寄存器状态表：
| 名字 | 状态 | 变量名 |
| ---- | ---- | ------ |
| R1   | 0/1  |        |

当需要用到一个寄存器时，可以用一个函数查找寄存器表，检查是否存在空闲寄存器，若存在，则将空闲的寄存器分配，然后按存取计算操作来操作，同时把相应的寄存器的状态和占用者记录在寄存器状态表

当所有寄存器都被占用时，涉及到寄存器的剥夺问题。剥夺算法优劣会影响目标程序的执行效率。
对寄存器的剥夺是把寄存器中的内容存入内存中。
理论上的最优是最远使用点方法，实现困难
局部最优是基本块内最远使用点方法

### 对目标程序的评价
- 每条指令对内存的访问次数总和决定了目标程序的执行效率。
- 指令的执行代价：访问内存一次的代价为1，例如间接寻址指令的代价较高
- 多利用寄存器中的资源可以达到减少访问内存的效果。

