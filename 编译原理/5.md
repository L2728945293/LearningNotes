# 语义分析
语法：关于什么样的字符串才是该语言在组成结构上合法的程序的法则。
语义：关于结构上合法的程序的意义法则

## 分类
静态语义
在编译阶段(compile-time)可以检查的语义
例如：标识符未声明

动态语义
目标程序运行时（run-time）才能检查的语义
例如：除零、溢出错误。 

## 语义分析的内容：
类型分析；
标识符相关信息提取；
## 语义分析的功能：
- 检查语义错误
### 类型检查
    各种条件表达式的类型是不是bool型?
    运算符的分量的类型是否相容?
    赋值语句的左右部的类型是否相容?
    形参和实参的类型是否相容?
    下标表达式的类型是否为所允许的类型?
    函数说明中的函数类型和返回值的类型是否一致?
### 一般性的语义检查
    V[E]中的V是不是变量,而且是数组类型？
    V.id中的V是不是变量,而且是记录类型? id是不是该记录类型中的域名?
    y+f(…)中的f是不是函数名?形参个数和实参个数是否一致?
    p(…)语句中的p是不是过程名?形参个数和实参个数是否一致?
    *V中的V是不是指针或文件变量？
    是否有变量的声明、标识符有没有重复声明？

- 构造标识符属性表（符号表）
### 标识符出现
1. 声明性
1. 使用性
### 标识符种类
- 常量标识符
- 类型标识符
- 变量标识符
    - 实在变量
    - 形参变量
        - 值引用型
        - 地址引用型
- 过函标识符
    - 实在过函
    - 形式过函
- 域名标识符
### 标识符属性
- 名字
- 种类信息
- 类型信息
- 对不同类型的独特的信息

### 标识符语义表示
#### 常量
| Name | kind | TypePtr | Value |
| --- | --- | --- | --- |

Name是常量的名字；
Kind = constKind，表明该标识符是常量标识符；
Type = TypePtr, 其中TypePtr是指向具体常量的类型的内部表示的指针；
Value = ValPtr，其中ValPtr是指向具体常量值的内部表示的指针。

#### 类型 (typedef)
| Name | kind | TypePtr |
| --- | --- | --- |

Name是类型标识符的名字；
Kind = typeKind, 表示标识符是类型标识符；
Type = TypePtr, 指向类型标识符指代的类型的内部表示。

#### 变量
| Name | kind | TypePtr | Access |Level | Off | Value |
| --- | --- | --- | --- | --- | --- | --- |

Kind = varKind，表明该标识符是变量标识符；
Access = dir表示变量是直接变量，Access = indir表示变量是间接变量；
Level表示该变量声明所在主程序/函数/过程的层数；
Off表示该变量相对它所在主程序/函数/过程的内存块起始地址的偏移量；
Value = ValPtr, 如果变量定义时说明了初值，则为初值的内部表示的指针，否则为空。

#### 域名
| Name | TypePtr | Kind | Off | HostType |
| --- | --- | --- | --- | --- |

Typeptr表示域名所对应域名标识符类型的内部表示
Kind=fieldKind，表明该标识符是域名标识符
Off 域名相对他所在记录的偏移量
HostType记录类型指针（宿主类型）
#### 过程/函数
| Name | TypePtr | kind | Level | Off | Param | Class | Code | Size | Forward | 
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

TypePtr表示函数返回值类型的内部表示(过程情形是NULL)
Kind = routKind； 
Level表示过/函的层数；
Off只对形式过/函有效，表示形式过/函在所属过/函内存块中的偏移；
Param表示过/函的参数表指针，参数表的结构同符号表的结构相同，参数信息可以填入符号表，也可以填入单独的参数表当中；
Class= actual表示实在过/函，Class = formal表示形式过/函；
Code只对实在过/函有效，表示过/函定义对应生成的目标代码的起始地址，当目标代码生成时回填得到，形式过/函的code为NULL；
Size只对实在过/函有效，表示过/函的目标代码所占内存区的大小，也要当目标代码生成以后回填得到；
Forward 属性只对实在过/函有效，Forward= true表示过/函是超前声明, Forward = false表示过/函不是超前声明。
**形式函数指没有具体实现的函数**
如
```c
int f(int a);
int f(int a, int b);
```

### 类型的语义表示
#### 分类
标准的类型：整形、实型、bool、字符类型， 这是标准的数据类型
自定义的数据类型，子界类型，枚举类型
结构数据类型：数组，集合，记录
特殊的指针类型，文件类型

#### 占用空间
为方便起见，规定RealSize取2,IntSize、BoolSize、CharSize取1。

#### 标准类型
| Size | Kind |
| --- | ---|

#### 子界类型
| Size | Kind | Low | Up | ElemType |
| --- | --- | --- | --- | --- |

#### 枚举类型
| Size | Kind | ElemList | 
| --- | --- | --- |

size表示枚举类型所占空间的大小；
Kind = enumTy；
ElemList是指向枚举常量表表头的指针.

内部表示
| Name | Value |
| --- | --- |

Name表示枚举常量的名字；
Value表示枚举常量所代表的整数值。

#### 数组类型
Size：Size = (Up-Low+1)*sizeof(ElemType)
Kind = ArrayTy, 表示是数组类型；
Low表示数组下标的下界，在C语言中Low = 0；
Up表示数组下标的上界；（low、up合在一起可以是子界类型）
ElemType 表示数组成分类型的内部表示指针。 

#### 结构体和联合体
| Size | Kind | RecBody |
| --- | --- | --- |

Kind=structTy 表示结构体类型
Kind=unionTy表示联合体类型

RecBody内部表示
| Name | TypePtr | Off | link |
| --- | --- | --- | --- |

Name表示域名
Typeptr指向域的类型
Off表示纪录域相对于结构体类型分配的内存块起始地址的偏移量，对于联合类型而言，所有的域名标识符的起始偏移都是相同的，所以可以省略；

#### 指针类型
| Size | Kind | BaseTy |
| --- | --- | --- |

size表示指针类型所占空间的大小，指地址的长度（一般一个单元）
Kind = pointTy表示是指针类型；
BaseType表示指针所指向空间的类型

#### 集合类型
| 大小 | 种类 | 基类型|
| --- | --- | --- |

程序设计语言中设定一个集合的时候都是设定成一个有限的集合，用$2^n$来确定


#### 文件类型
| Size | Kind | 缓冲区类型 |
| --- | --- | --- |

大小指的是缓冲区的大小

## 语义分析的实现：
与语法分析相结合

## 抽象地址
### 分配
- 静态分配
在编译时间即为所有数据对象分配固定的地址单元，且这些地址在运行时间始终保持不变。是一种直观的方法，但不适用于动态申请空间。
- 动态分配
程序中变量分配的地址不是具体的地址，而是一个抽象地址，当程序运行时根据抽象地址分配具体的物理地址。
### 结构
| 层数 | 偏移 |
| --- | --- |

层数主要是针对嵌套式语言，表示的是某个函数所处的嵌套定义层数。
偏移是针对过程活动记录的一个相对偏移量 

- 嵌套式语言中：
主程序设为0层
主程序直接定义的函数和过程定义为1层
若某函数为L层，则该函数直接定义的函数为L+1层
- 并列式语言中:
全局变量定义为0层，函数中的变量定义为1层

### 过程活动记录
每次函数被调用时都会给函数分配一片空间，用以存储如图信息，我们把这片存储空间称作过程活动记录
偏移是针对过程活动记录的，通过起始位置+偏移量就可以找到对应的物理位置。
过程活动记录中存储的顺序实际上是处理的先后顺序
| 临时变量区 |
| --- |
| 局部变量区 |
| 形参区 |
| 管理信息 |

### 空间分配
临时变量一律一个单元
局部变量按类型大小分

形参
- 地址引用型形参：分一个单元
- 值引用型形参：按类型大小分
- 过/函形参：分两个单元（入口地址，display表信息）

## 符号表
符号表存储的是标识符的语义信息，包含两部分：标识符的名字；语义字(种类、类型、抽象地址...)
符号表的总体组织既可以采用多表结构，也可以采用单表结构,也可以二者折中。究竟采用哪种结构并没有统一的规定，编译程序可根据实际处理语言的需要进行选择。

### New token与符号表关系
- 声明性出现：
<标识符，a> 创建标识符a所对应的符号表，将token转化为 <标识符，指针（符号表中创建的项）>
- 使用性出现：
<标识符，a> 到符号表中查找a，找到则将token转化为<标识符，指针（符号表中查找到的项）>

查表三种方法：
- 顺序查找
- 二分查找
- 哈希查找

### 标识符作用域
指某标识符可以有效使用的范围，标识符的作用域是一个程序段，称之为程序的**局部化区**，通常是一个子程序或者分程序，局部化区是允许含有声明的最小程序单位

在一个程序的局部化区里，同一个标识符不能被声明两次
强类型语言规定标识符必须先声明后使用，弱类型语言无要求。

### 标识符处理原则
1. 每进入一个局部化区，记录本层符号表的首地址
1. 遇到声明性标识符时，构造其语义字，查本层的符号表，检查是否有重名，有则出错，否则就把其语义字填到符号表里。
1. 遇到使用性出现，查符号表，如果查到则读取其语义字，否则出现语义错误。
1. 退出一个局部化区，'作废'本层的符号表

### 嵌套式和并列式
- 从处理难度角度来说，可能嵌套式语言复杂，并列式简单
- 并列式语言的局部化区比较固定，层数分成两层，全局量定义成0层，局部量定义成1层。分配地址特殊情形就是分程序结构，分程序可以是嵌套的，他的层数都是看成同一层，查局部化区每个分程序看成一个独立的局部化区。
- 分配抽象地址的时候为了节省空间，并列的分程序可以是并行的分配，嵌套的分程序必须要连续的往下分，前一个分程序从10-100，并列的可以是10-200。 还有变量运行环境，在嵌套式语言里要考虑。 

## 符号表管理
### Pascal语言符号表管理
- Pascal语言的最大特点就是允许嵌套的过程声明。规定Pascal主程序的层数为0，在主程序中声明的标识符(包括过/函标识符)的层数为1，在第i层过/函中声明的标识符(包括形参和局部标识符)的层数为i+1(i≥1)。
- 用一个Scope栈来实现标识符的嵌套作用域。
- Scope栈的每项指向当前仍有效的某层符号表的首项，具体说Scope(0) 指向0层符号表的首项，Scope(i) 指向i层符号表的首项。 
#### 删除法
#### 跳转法

### C语言符号表管理
- C语言不允许函数的嵌套声明。
- 一个C程序是由若干个函数并列组成的（其中一定要有main函数），这些函数的地位都是相同的。从main函数调用开始执行，在后面声明的函数可以调用在它之前声明的函数。
- C语言的每个标识符的层次只有两个，即0层和1层。全局标识符和所有的函数标识符的层数是0，函数的形式参数和局部标识符的层数是1。
#### 驻留法
基本同Pascal跳转法
#### 删除法

### goto和标号处理
#### 标号出现形式
- 声明性出现 在程序的声明部分给出一个声明，声明哪些标识符是标号。例如：label R1,R2
- 定位性出现 起到定位的作用，例如： R1：s, s是一个语句，R1是一个语句标号，表示R1这个语句标号定位在s语句前面
- 转移性出现 例如goto R1, 即把程序的控制结构转到标号为R1的位置上开始去执行

#### 可能的错误
- 标号的重复声明
- 标号的重复定位
- 使用的标号未声明（语言决定的）
- 有转移但是无定位
#### 实现
一般有两种实现方式：
1. goto R -> Jump R 
效率较高但实现困难，难以定位跳转地址
1. goto R -> Jump *R
为标号分配一个存储单元，跳转指令采用间接寻址方式，从对应存储单元中读取该标号定位的地址。 

通常采用第二种实现方式

1. 分配存储单元
1. 检查语义错误

两个表：
标号表
| 标号名 | 状态标志 | 地址 |
| --- | --- | --- |

状态标志：0表示未定位，1表示已定位

未找到定位标号表
| 标号名 | 
| --- |
| 标号名 | 
| 标号名 | 

遇到声明性标号时查标号表
1. 如果表中有该标号，说明该标号被重复声明
1. 如果没有，则将标号填到符号表里，状态填0

遇到定位性标号时查标号表
1. 没查到，报错（标号未声明）
1. 查到，状态位为0，则将其变为1，生成目标代码时回填地址。状态位为1，报错（标号重复定位）

遇到转移性标号时查标号表
1. 查到，则建立指针；查不到，将该标号填入'未找到定位标号表'
1. 程序单位结束时，复查'未找到定位标号表'，确定是否存在错误。

