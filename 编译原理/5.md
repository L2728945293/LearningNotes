# 语义分析
语法：关于什么样的字符串才是该语言在组成结构上合法的程序的法则。
语义：关于结构上合法的程序的意义法则

## 分类
静态语义
在编译阶段(compile-time)可以检查的语义
例如：标识符未声明

动态语义
目标程序运行时（run-time）才能检查的语义
例如：除零、溢出错误。 

## 语义分析的内容：
类型分析；
标识符相关信息提取；
## 语义分析的功能：
- 检查语义错误
### 类型检查
    各种条件表达式的类型是不是bool型?
    运算符的分量的类型是否相容?
    赋值语句的左右部的类型是否相容?
    形参和实参的类型是否相容?
    下标表达式的类型是否为所允许的类型?
    函数说明中的函数类型和返回值的类型是否一致?
### 一般性的语义检查
    V[E]中的V是不是变量,而且是数组类型？
    V.id中的V是不是变量,而且是记录类型? id是不是该记录类型中的域名?
    y+f(…)中的f是不是函数名?形参个数和实参个数是否一致?
    p(…)语句中的p是不是过程名?形参个数和实参个数是否一致?
    *V中的V是不是指针或文件变量？
    是否有变量的声明、标识符有没有重复声明？

- 构造标识符属性表（符号表）
### 标识符出现
1. 声明性
1. 使用性
### 标识符种类
- 常量标识符
- 类型标识符
- 变量标识符
    - 实在变量
    - 形参变量
        - 值引用型
        - 地址引用型
- 过函标识符
    - 实在过函
    - 形式过函
- 域名标识符
### 标识符属性
- 名字
- 种类信息
- 类型信息
- 对不同类型的独特的信息

### 标识符语义表示
#### 常量
| Name | kind | TypePtr | Value |
| --- | --- | --- | --- |

Name是常量的名字；
Kind = constKind，表明该标识符是常量标识符；
Type = TypePtr, 其中TypePtr是指向具体常量的类型的内部表示的指针；
Value = ValPtr，其中ValPtr是指向具体常量值的内部表示的指针。

#### 类型 (typedef)
| Name | kind | TypePtr |
| --- | --- | --- |

Name是类型标识符的名字；
Kind = typeKind, 表示标识符是类型标识符；
Type = TypePtr, 指向类型标识符指代的类型的内部表示。

#### 变量
| Name | kind | TypePtr | Access |Level | Off | Value |
| --- | --- | --- | --- | --- | --- | --- |

Kind = varKind，表明该标识符是变量标识符；
Access = dir表示变量是直接变量，Access = indir表示变量是间接变量；
Level表示该变量声明所在主程序/函数/过程的层数；
Off表示该变量相对它所在主程序/函数/过程的内存块起始地址的偏移量；
Value = ValPtr, 如果变量定义时说明了初值，则为初值的内部表示的指针，否则为空。

#### 域名
| Name | TypePtr | Kind | Off | HostType |
| --- | --- | --- | --- | --- |

Typeptr表示域名所对应域名标识符类型的内部表示
Kind=fieldKind，表明该标识符是域名标识符
Off 域名相对他所在记录的偏移量
HostType记录类型指针（宿主类型）
#### 过程/函数
| Name | TypePtr | kind | Level | Off | Param | Class | Code | Size | Forward | 
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

TypePtr表示函数返回值类型的内部表示(过程情形是NULL)
Kind = routKind； 
Level表示过/函的层数；
Off只对形式过/函有效，表示形式过/函在所属过/函内存块中的偏移；
Param表示过/函的参数表指针，参数表的结构同符号表的结构相同，参数信息可以填入符号表，也可以填入单独的参数表当中；
Class= actual表示实在过/函，Class = formal表示形式过/函；
Code只对实在过/函有效，表示过/函定义对应生成的目标代码的起始地址，当目标代码生成时回填得到，形式过/函的code为NULL；
Size只对实在过/函有效，表示过/函的目标代码所占内存区的大小，也要当目标代码生成以后回填得到；
Forward 属性只对实在过/函有效，Forward= true表示过/函是超前声明, Forward = false表示过/函不是超前声明。
**形式函数指没有具体实现的函数**
如
```c
int f(int a);
int f(int a, int b);
```

### 类型的语义表示
#### 分类
标准的类型：整形、实型、bool、字符类型， 这是标准的数据类型
自定义的数据类型，子界类型，枚举类型
结构数据类型：数组，集合，记录
特殊的指针类型，文件类型

#### 占用空间
为方便起见，规定RealSize取2,IntSize、BoolSize、CharSize取1。

#### 标准类型
| Size | Kind |
| --- | ---|

#### 子界类型
| Size | Kind | Low | Up | ElemType |
| --- | --- | --- | --- | --- |

#### 枚举类型
| Size | Kind | ElemList | 
| --- | --- | --- |

size表示枚举类型所占空间的大小；
Kind = enumTy；
ElemList是指向枚举常量表表头的指针.

内部表示
| Name | Value |
| --- | --- |

Name表示枚举常量的名字；
Value表示枚举常量所代表的整数值。

#### 数组类型
Size：Size = (Up-Low+1)*sizeof(ElemType)
Kind = ArrayTy, 表示是数组类型；
Low表示数组下标的下界，在C语言中Low = 0；
Up表示数组下标的上界；（low、up合在一起可以是子界类型）
ElemType 表示数组成分类型的内部表示指针。 

#### 结构体和联合体
| Size | Kind | RecBody |
| --- | --- | --- |

Kind=structTy 表示结构体类型
Kind=unionTy表示联合体类型

RecBody内部表示
| Name | TypePtr | Off | link |
| --- | --- | --- | --- |

Name表示域名
Typeptr指向域的类型
Off表示纪录域相对于结构体类型分配的内存块起始地址的偏移量，对于联合类型而言，所有的域名标识符的起始偏移都是相同的，所以可以省略；

#### 指针类型
| Size | Kind | BaseTy |
| --- | --- | --- |

size表示指针类型所占空间的大小，指地址的长度（一般一个单元）
Kind = pointTy表示是指针类型；
BaseType表示指针所指向空间的类型

#### 集合类型
| 大小 | 种类 | 基类型|
| --- | --- | --- |

程序设计语言中设定一个集合的时候都是设定成一个有限的集合，用$2^n$来确定


#### 文件类型
| Size | Kind | 缓冲区类型 |
| --- | --- | --- |

大小指的是缓冲区的大小



## 语义分析的实现：
与语法分析相结合

